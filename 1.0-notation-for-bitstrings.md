# 1.0 Notation for bitstrings

### 1 Overview Contents

This chapter provides an overview of the main features and design principles\
of TVM. More detail on each topic is provided in subsequent chapters.

#### 1.0 Notation for bitstrings

The following notation is used for bit strings (orbitstrings)—i.e., finite strings\
consisting of binary digits (bits), 0 and 1 —throughout this document.

1.0.1. Hexadecimal notation for bitstrings. When the length of a bit-\
string is a multiple of four, we subdivide it into groups of four bits and\
represent each group by one of sixteen hexadecimal digits 0 – 9 ,A–Fin the\
usual manner: 016 ↔ 0000 , 116 ↔ 0001 ,... ,F 16 ↔ 1111. The resulting\
hexadecimal string is our equivalent representation for the original binary\
string.

1.0.2. Bitstrings of lengths not divisible by four. If the length of a\
binary string is not divisible by four, we augment it by one 1 and several\
(maybe zero) 0 s at the end, so that its length becomes divisible by four, and\
then transform it into a string of hexadecimal digits as described above. To\
indicate that such a transformation has taken place, a special “completion\
tag”_is added to the end of the hexadecimal string. The reverse transforma-_\
_tion (applied if the completion tag is present) consists in first replacing each_\
_hexadecimal digit by four corresponding bits, and then removing all trailing_\
_zeroes (if any) and the last 1 immediately preceding them (if the resulting_\
_bitstring is non-empty at this point)._\
_Notice that there are several admissible hexadecimal representations for_\
_the same bitstring. Among them, the shortest one is “canonical”. It can be_\
_deterministically obtained by the above procedure._\
_For example,8Acorresponds to binary string 10001010 , while8A_ and\
8A0\_both correspond to 100010. An empty bitstring may be represented by\
either ‘’, ‘8\_’, ‘0\_’, ‘_’, or ‘00_’.

1.0.3. Emphasizing that a string is a hexadecimal representation of\
a bitstring.Sometimes we need to emphasize that a string of hexadecimal\
digits (with or without a\_at the end) is the hexadecimal representation of\
a bitstring. In such cases, we either prependxto the resulting string (e.g.,\
x8A), or prependx{and append}(e.g.,x{2D9\_}, which is 00101101100 ).

#### 1.1 TVM is a stack machine

This should not be confused with hexadecimal numbers, usually prepended\
by0x(e.g.,0x2D9or0x2d9, which is the integer 729).

1.0.4. Serializing a bitstring into a sequence of octets. When a bit-\
string needs to be represented as a sequence of 8-bit bytes (octets), which\
take values in integers 0 ... 255 , this is achieved essentially in the same fash-\
ion as above: we split the bitstring into groups of eight bits and interpret\
each group as the binary representation of an integer 0 ... 255. If the length\
of the bitstring is not a multiple of eight, the bitstring is augmented by a\
binary 1 and up to seven binary 0 s before being split into groups. The fact\
that such a completion has been applied is usually reflected by a “completion\
tag” bit.\
For instance, 00101101100 corresponds to the sequence of two octets\
(0x2d,0x90)(hexadecimal), or(45,144)(decimal), along with a completion\
tag bit equal to 1 (meaning that the completion has been applied), which\
must be stored separately.\
In some cases, it is more convenient to assume the completion is enabled\
by default rather than store an additional completion tag bit separately.\
Under such conventions, 8 n-bit strings are represented byn+ 1octets, with\
the last octet always equal to0x80= 128.

#### 1.1 TVM is a stack machine

First of all,TVM is a stack machine. This means that, instead of keeping\
values in some “variables” or “general-purpose registers”, they are kept in a\
(LIFO)stack, at least from the “low-level” (TVM) perspective.^3\
Most operations and user-defined functions take their arguments from the\
top of the stack, and replace them with their result. For example, the inte-\
ger addition primitive (built-in operation)ADDdoes not take any arguments\
describing which registers or immediate values should be added together and\
where the result should be stored. Instead, the two top values are taken from\
the stack, they are added together, and their sum is pushed into the stack in\
their place.

(^3) A high-level smart-contract language might create a visibility of variables for the\
ease of programming; however, the high-level source code working with variables will be\
translated into TVM machine code keeping all the values of these variables in the TVM\
stack.
